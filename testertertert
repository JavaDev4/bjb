// Get existing addresses from the database
List<LinkedHashMap<String, String>> existingAddresses = addressInfo.getExistingAddresses();

// Initialize lists for unmatched addresses
List<AddressDto> unmatchedDtoAddresses = new ArrayList<>();
List<LinkedHashMap<String, String>> unmatchedApiAddresses = new ArrayList<>();

// Check if ECI and ACBS_IDENTIFIER are not null
if (item.getECI() != null && item.getPARTY_IDENTIFIER() != null) {
    PartyCentralClientResponse partyCentralResponse = partyCentralClientApiService.fetchClientByEci(item.getECI());

    // Check DTO addresses against API addresses
    for (AddressDto addressDto : addrDtoList) {
        boolean addressExists = existingAddresses.stream()
            .anyMatch(existingAddress -> compareAddresses(existingAddress, addressDto));

        if (!addressExists) {
            unmatchedDtoAddresses.add(addressDto);
        }
    }

    // Check API addresses against DTO addresses
    for (LinkedHashMap<String, String> existingAddress : existingAddresses) {
        boolean addressExists = addrDtoList.stream()
            .anyMatch(addressDto -> compareAddresses(existingAddress, addressDto));

        if (!addressExists) {
            unmatchedApiAddresses.add(existingAddress);
        }
    }

    // Add unmatched DTO addresses
    for (AddressDto addressDto : unmatchedDtoAddresses) {
        maxAddressIdentifier++;
        String addressIdentifierFormat = String.format("%03d", maxAddressIdentifier);

        AcbsAddAddressRequest addAddressRequest = addAddressBuilder.addAddressRequest(
            partyCentralResponse, addressDto, addressIdentifierFormat, customerId, createTransformation());

        String addressIdentifier = addAddressService.addAddress(customerId, addAddressRequest);
        if (addressIdentifier != null) {
            descriptionMsgList.add(createCustomerBuilder.getIdentifierValue(addressIdentifier));
            log.info("Address Identifier: {}", addressIdentifier);
        }
    }

    // Add unmatched API addresses (if needed, you may need to convert these to DTOs or another suitable format)
    for (LinkedHashMap<String, String> existingAddress : unmatchedApiAddresses) {
        // Convert existingAddress to AddressDto or suitable format if required
        AddressDto addressDto = convertToAddressDto(existingAddress);
        maxAddressIdentifier++;
        String addressIdentifierFormat = String.format("%03d", maxAddressIdentifier);

        AcbsAddAddressRequest addAddressRequest = addAddressBuilder.addAddressRequest(
            partyCentralResponse, addressDto, addressIdentifierFormat, customerId, createTransformation());

        String addressIdentifier = addAddressService.addAddress(customerId, addAddressRequest);
        if (addressIdentifier != null) {
            descriptionMsgList.add(createCustomerBuilder.getIdentifierValue(addressIdentifier));
            log.info("Address Identifier: {}", addressIdentifier);
        }
    }
}

// Method to compare addresses
private boolean compareAddresses(LinkedHashMap<String, String> existingAddress, AddressDto addressDto) {
    String apiStateCode = existingAddress.get("State");
    String apiCountryCode = existingAddress.get("Country");
    String apiPostalCode = existingAddress.get("PostalCode");
    String apiPostalCode1 = null;
    if (apiPostalCode != null && apiPostalCode.length() > 5) {
        apiPostalCode1 = apiPostalCode.substring(0, 5);
    }

    return existingAddress.get("Street1").equals(addressDto.getAddr1())
        && existingAddress.get("Street2").equals(addressDto.getAddr2())
        && existingAddress.get("Street3").equals(addressDto.getAddr3())
        && existingAddress.get("Street4").equals(addressDto.getAddr4())
        && existingAddress.get("City").equals(addressDto.getCity())
        && (apiPostalCode1 != null ? apiPostalCode1.equals(addressDto.getZip_code().substring(0, 5)) : apiPostalCode.equals(addressDto.getZip_code()))
        && apiStateCode.equals(addressDto.getState())
        && apiCountryCode.equals(addressDto.getCountry());
}

// Example conversion method if needed (implement this based on your actual needs)
private AddressDto convertToAddressDto(LinkedHashMap<String, String> existingAddress) {
    AddressDto addressDto = new AddressDto();
    addressDto.setAddr1(existingAddress.get("Street1"));
    addressDto.setAddr2(existingAddress.get("Street2"));
    addressDto.setAddr3(existingAddress.get("Street3"));
    addressDto.setAddr4(existingAddress.get("Street4"));
    addressDto.setCity(existingAddress.get("City"));
    addressDto.setZip_code(existingAddress.get("PostalCode"));
    addressDto.setState(existingAddress.get("State"));
    addressDto.setCountry(existingAddress.get("Country"));
    return addressDto;
}
